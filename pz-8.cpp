#include <iostream>
#include <map>
#include <string>
using namespace std;
int eggs(){
    /*
    Задача: 
        Найти минимальное число, сравнимое с 1 по модулю 2, 3, 4, 5, 6 и кратно 7. Назовем искомое число n.
    Ограничения n: 
        n - это натуральное число. (0 яиц быть не может, так как 0 кратен 2, 3 и т.д.)
    Упрощение:
        Заметим, что то, что n сравнимо с 1 (mod 2) значит, что оно нечетно. Так как число сравнимо также с 1 (mod 4), то n можно представить как 4*k4+1, где k4 - натуральное число. 
        Из этого следует, что n - нечетно, так как 4k4 - четно. Значит (n сравнимо с 1 (mod 2) и n сравнимо с 1 (mod 4)) эквивалентно (n сравнимо с 1 (mod 4)).
        Тогда можем упростить условие до:
        (n сравнимо с 1 (mod 3)) и (n сравнимо с 1 (mod 4)) и (n сравнимо с 1 (mod 5)) и (n сравнимо с 1 (mod 6)) и (n кратно 7)
        Изходя из этого, мы можем сказать, что число (n-1) кратно 3, 4, 5, 6. Другими словами, число (n-1) кратно 60.
        Обозначим число (n-1) как x.
        Тогда исходную задачу можно свести к задаче: Найти такое x, кратное 60, чтобы число (x+1) было кратно 7.
        Наше искомое n = x+1.
    Реализация:
    */
    int n = 61;
    while ((n)%7){
        n+=60;
    }
    return (n);
}
int* count(int * x, int n){ //x - массив целых чисел, n - размер массива x
    /*
    Задача:
        Задана перестановка  X [0:n–1].Сформировать новый массив X1 [0:n–1], в котором Х1[i] = числу элементов в X[0:i–1], меньших X[i] 
        (с учетом того условия,что в Х1 последний элемент всегда будет совпадать с последним элементом в Х ).
    Ограничения:
        n - натуральное число или 0. Если n=0, просто вернуть исходный массив.
        Элементами X являются целые числа
    Мат. модель:
        Понятно, что если i=0, то X1[i] = 0, так как до нулевого элемента в массиве вообще нет элементов, а значит нет и элементов меньше X[i].
        Будем хранить отсортированный словарь, где ключ - это число, которое встречалось в массиве, а по ключу храниться пара значений.
        Первое - это сколько чисел меньше данного встетилось. Обозначим как K[i].s .
        Второе - это сколько раз данное число уже встретилось. Обозначим как K[i].c .
        Будем обозначать операцию добавления нового ключа со значением так: K[i] = {s1, c1}, 
        где i - значение ключа, s1 - сколько чисел меньше i встетилось, c1 - сколько раз i уже встретилось.
        Словарь этот назовем K.
        Вначале словарь пустой.
        Введем функцию M(). Пусть M(m)=наибольший ключ в K, который был бы меньше, чем m.
    Алгоритм:
        Проходить массив будем слева направо, перебирая по-очереди i от 0 до n-1.
            Если X[i] не является ключом в K (мы еще не встречали такое число), тогда X1[i] = K[M(X[i])].s + 1. 
                После этого добавим значение по ключу K[i] = {K[M(X[i])].s + K[M(X[i])].c, 1}.
            Если X[i] является ключом в K, тогда X1[i] = K[X[i]].s.
                После этого изменим K[i].c, оно увеличится на 1.
            Далее для всех ключей больше i пересчитаем K[i].s . Оно станет больше на 1 у каждого.
        
        В конце выводим получившийся X1
    */
    int * x1 = new int [n];
    map <int, pair<int, pair<int, int>>> k = { {x[0], {x[0], {0, 1}}} };
    x1[0] = 0;
    int max_key = x[0];
    int node;
    for(int i = 1; i<n; i++){
        node = max_key;
        if(max_key < x[i]){
            k[x[i]] = {node, {k[node].second.first+k[node].second.second, 1}};
            x1[i] = k[x[i]].second.first;
            max_key = x[i];
        }
        else{
            while(k[node].first != node and k[node].first >= x[i]){
                k[node].second.first ++;
                node = k[node].first;
            }
            if(node == x[i]){
                x1[i] = k[node].second.first;
                k[node].second.second ++;
            }
            else{
                if (k[node].first == node){
                    k[x[i]] = {x[i], {x1[i], 1}};
                    x1[i] = 0;
                }
                else{
                    k[x[i]] = {k[node].first, {k[k[node].first].second.first+k[k[node].first].second.second, 1}};
                    x1[i] = k[x[i]].second.first;
                }
                k[node].first = x[i];
                k[node].second.first ++;
            }
        }
    }
    return x1;
    
}
void arrange(int x, int m, int n, int* b) {
    int p = m;
    for (int i = m; i < n; i++) {
        if (b[i] <= x) {
            swap(b[i], b[p]);
            p++;
        }
    }
    cout <<endl<< "P = " << p << endl;
    cout << "b[m:p-1] = ";
    for (int i = m; i < p; i++){ 
        cout<< b[i]<<" "; 
    }
    cout << endl << "b[p:n-1] = ";
    for (int j=p; j<n; j++){
        cout<<b[j]<<" ";
    }
    cout << endl;
}

string squeeze (string s){
    //Идем справа на лево, чтобы коэфиценты удобнее было расчитывать
    int count_eq = 0;
    for (int i = s.length()-1; i > 0; --i) {
        if(s[i] == s[i-1]){
            count_eq ++;
        }
        else{
            if(count_eq!=0){
                s.erase(i, count_eq);
                count_eq = 0;
            }
        }
    }
    if(count_eq){
            s.erase(0, count_eq);
    }
    return s;
}

int main()
{
    cout<<"Ответ на первую задачу: "<<eggs()<<endl;
    cout<<endl;
    
    int n;
    cout<<"Задача №2"<<endl<<"Введите размер массива: ";
    cin>>n;
    int *x = new int [n];
    for(int i = 0; i<n; i++){
        cout<<"Введите элемент №"<<i<<": ";
        cin>>x[i];
    }
    cout<<"Пример для второй задачи: ";
    for(int i = 0; i< n; i++){
        cout<<x[i];
    }
    cout<<endl;
    int *x1 = count(x, n);
    cout<<"Ответ на вторую задачу: ";
    for(int i = 0; i<n; i++){
        cout<<x1[i];
    }
    delete x, x1;
    cout<<endl<<endl;
    
    cout<<"Задача №3"<<endl<<"Введите размер массива: ";
    cin>>n;
    int *b = new int [n];
    for(int i = 0; i<n; i++){
        cout<<"Введите элемент №"<<i<<": ";
        cin>>x[i];
    }
    int m, n1;
    cout<<"Введите m: ";
    cin>>m;
    cout<<"Введите n: ";
    cin>>n1;
    if(n<=n1 or n<=m or n1<0 or m<0){
        cout<<"Ошибка, такой срез не возможен"<<endl;
    }
    else{
        cout<<"Пример для третий задачи: ";
        for(int i = 0; i< n; i++){
            cout<<b[i];
        }
        cout<<endl<<"m = "<<m<<", n = "<<n1<<endl;
        arrange(n, m, n, b);
        delete b;
    }
    cout<<endl;
    
    string s;
    cout<<"Введите строку для сжатия: ";
    cin>>s;
    cout<<"Ответ на четвертую задачу: "<<squeeze(s)<<endl;
    
    return 0;
}